# .github/workflows/sync-upstream.yml
name: Sync Upstream

on:
  schedule:
    - cron: '0 0 * * *'
  workflow_dispatch:

concurrency:
  group: sync-upstream-${{ github.repository }}
  cancel-in-progress: true

permissions:
  contents: write
  pull-requests: write

env:
  # configure these to point at the upstream repo and branch you want to sync from
  UPSTREAM_REPO: igcyukira/i0c.cc
  UPSTREAM_BRANCH: main
  TARGET_BRANCH: main
  # PAT must be stored in repository secrets as PAT
  PAT: ${{ secrets.PAT }}

jobs:
  sync:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout target branch (full history)
        uses: actions/checkout@v6
        with:
          ref: ${{ env.TARGET_BRANCH }}
          fetch-depth: 0
          token: ${{ secrets.PAT }}

      - name: Ensure git user
        run: |
          git config --global user.name 'IGCrystal-G'
          git config --global user.email 'cacheigcrystal@gmail.com'

      - name: Install dependencies (jq)
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq

      - name: Sync from upstream and create/merge PR if needed
        env:
          PAT: ${{ secrets.PAT }}
          UPSTREAM_REPO: ${{ env.UPSTREAM_REPO }}
          UPSTREAM_BRANCH: ${{ env.UPSTREAM_BRANCH }}
          TARGET_BRANCH: ${{ env.TARGET_BRANCH }}
        run: |
          set -euxo pipefail

          # Add upstream remote (ignore error if already exists)
          git remote add upstream "https://github.com/${UPSTREAM_REPO}.git" || true

          # Fetch full upstream and origin (avoid shallow fetch to prevent missing objects)
          git fetch upstream ${UPSTREAM_BRANCH} || git fetch --unshallow upstream ${UPSTREAM_BRANCH} || git fetch upstream ${UPSTREAM_BRANCH}
          git fetch origin ${TARGET_BRANCH} || git fetch --unshallow origin ${TARGET_BRANCH} || git fetch origin ${TARGET_BRANCH}

          # If upstream is already an ancestor of HEAD, nothing to do
          if git merge-base --is-ancestor upstream/${UPSTREAM_BRANCH} HEAD 2>/dev/null; then
            echo "Upstream already merged into HEAD — nothing to do."
            exit 0
          fi

          # create a uniquely named branch
          BRANCH_NAME="sync-upstream-$(date +%Y%m%d-%H%M%S)"
          git checkout -b "$BRANCH_NAME"

          # merge upstream into this branch (allow unrelated histories to be robust)
          # allow failure to be tolerated so we can inspect diff later
          git merge --no-edit --allow-unrelated-histories upstream/${UPSTREAM_BRANCH} || true

          # if no changes compared to origin/target branch, exit
          if git diff --quiet origin/${TARGET_BRANCH}..HEAD; then
            echo "No effective changes vs origin/${TARGET_BRANCH} — exiting."
            exit 0
          fi

          # perform repack and gc to produce clean pack objects before pushing
          git repack -a -d || true
          git gc --prune=now --aggressive || true

          # push new branch with retries (handle transient network/Git issues)
          PUSH_ATTEMPTS=0
          until [ "$PUSH_ATTEMPTS" -ge 5 ]
          do
            git push --set-upstream origin "$BRANCH_NAME" && break
            PUSH_ATTEMPTS=$((PUSH_ATTEMPTS+1))
            echo "Push attempt $PUSH_ATTEMPTS failed, retrying in 5s..."
            sleep 5
          done
          if [ "$PUSH_ATTEMPTS" -ge 5 ]; then
            echo "Push failed after multiple attempts."
            exit 1
          fi

          # GitHub API helpers
          API_URL="https://api.github.com/repos/${GITHUB_REPOSITORY}"
          OWNER=${GITHUB_REPOSITORY%%/*}

          # wait until branch is visible on GitHub (avoid race)
          for i in $(seq 1 10); do
            if curl -s -H "Authorization: token ${PAT}" -H "Accept: application/vnd.github+json" "${API_URL}/git/ref/heads/${BRANCH_NAME}" | jq -e .ref >/dev/null 2>&1; then
              echo "Branch ${BRANCH_NAME} visible on GitHub."
              break
            fi
            echo "Waiting for branch to appear on GitHub... ($i)"
            sleep 1
            if [ "$i" -eq 10 ]; then
              echo "Branch did not appear on GitHub in time."
              exit 1
            fi
          done

          # check existing open PR for same head/base
          EXISTING_PR_COUNT=$(curl -s -H "Authorization: token ${PAT}" -H "Accept: application/vnd.github+json" \
            "${API_URL}/pulls?state=open&head=${OWNER}:${BRANCH_NAME}&base=${TARGET_BRANCH}" | jq 'length')

          if [ "${EXISTING_PR_COUNT}" -gt 0 ]; then
            echo "An open PR already exists for ${BRANCH_NAME}. Skipping PR creation."
          else
            # create pull request
            CREATE_PR_RESP=$(curl -s -X POST \
              -H "Authorization: token ${PAT}" \
              -H "Accept: application/vnd.github+json" \
              "${API_URL}/pulls" \
              -d "{\"title\":\"chore: sync upstream ${BRANCH_NAME}\",\"head\":\"${OWNER}:${BRANCH_NAME}\",\"base\":\"${TARGET_BRANCH}\",\"body\":\"Auto sync from upstream\"}")

            PR_NUMBER=$(echo "$CREATE_PR_RESP" | jq -r '.number // empty' || true)
            if [ -z "$PR_NUMBER" ]; then
              echo "create pr failed: $CREATE_PR_RESP"
              exit 1
            fi

            # attempt to merge PR automatically (merge_method can be 'merge', 'squash', or 'rebase')
            MERGE_RESP=$(curl -s -X PUT \
              -H "Authorization: token ${PAT}" \
              -H "Accept: application/vnd.github+json" \
              "${API_URL}/pulls/${PR_NUMBER}/merge" \
              -d '{"merge_method":"merge"}')

            MERGED=$(echo "$MERGE_RESP" | jq -r '.merged // false' || true)
            if [ "$MERGED" = "true" ]; then
              # delete branch if merged
              curl -s -X DELETE -H "Authorization: token ${PAT}" -H "Accept: application/vnd.github+json" "${API_URL}/git/refs/heads/${BRANCH_NAME}" || true
              echo "PR merged and branch cleaned up."
            else
              echo "PR created but not merged automatically: $MERGE_RESP"
            fi
          fi

          # cleanup old sync-upstream-* branches that have no open PRs
          for ref in $(git ls-remote --heads origin "sync-upstream-*" | awk '{print $2}' | sed 's#refs/heads/##'); do
            OPEN_PR_COUNT=$(curl -s -H "Authorization: token ${PAT}" -H "Accept: application/vnd.github+json" "${API_URL}/pulls?state=open&head=${OWNER}:${ref}" | jq 'length')
            if [ "$OPEN_PR_COUNT" -eq 0 ]; then
              echo "Deleting stale branch: $ref"
              curl -s -X DELETE -H "Authorization: token ${PAT}" -H "Accept: application/vnd.github+json" "${API_URL}/git/refs/heads/${ref}" || true
            fi
          done
